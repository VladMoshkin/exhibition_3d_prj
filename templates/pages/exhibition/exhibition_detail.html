{% extends "base/base.html" %}
{% load staticfiles i18n %}

{% block title %}{{exhibition.title}}{% endblock %}

{% block pagetitle %}{{exhibition.title}}{% endblock %}

{% block content %}
		<script src="{% static 'js/three.js' %}"></script>
		<script src="{% static 'js/PointerLockControls.js' %}"></script>

    <div id="blocker">

			<div id="instructions">
				<span style="font-size:120px">Название выставки</span>
				<br />
				<br />
				(W, A, S, D = Движение, MOUSE = Смотреть по сторонам и наслаждаться)
			</div>

		<script>
    var camera, scene, renderer, controls;
    var objects = [];
    var raycaster;
    var blocker = document.getElementById( 'blocker' );
    var instructions = document.getElementById( 'instructions' );

    var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
    if ( havePointerLock ) {
      var element = document.body;
      var pointerlockchange = function ( event ) {
        if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
          controlsEnabled = true;
          controls.enabled = true;
          blocker.style.display = 'none';
        } else {
          controls.enabled = false;
          blocker.style.display = 'block';
          instructions.style.display = '';
        }
      };
      var pointerlockerror = function ( event ) {
        instructions.style.display = '';
      };

      document.addEventListener( 'pointerlockchange', pointerlockchange, false );
      document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
      document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );
      document.addEventListener( 'pointerlockerror', pointerlockerror, false );
      document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
      document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );
      instructions.addEventListener( 'click', function ( event ) {
        instructions.style.display = 'none';
        // Block screen
        element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
        element.requestPointerLock();
      }, false );
    } else {
      instructions.innerHTML = 'Ваш браузер не поддерживает блокировку указателя';
    }
    init();
    animate();
    var controlsEnabled = false;
    var moveForward = false;
    var moveBackward = false;
    var moveLeft = false;
    var moveRight = false;
    var canJump = false;
    var prevTime = performance.now();
    var velocity = new THREE.Vector3();
    var direction = new THREE.Vector3();
    function init() {
      camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );
      scene = new THREE.Scene();
      scene.background = new THREE.Color( 0xffffff );
      scene.fog = new THREE.Fog( 0xffffff, 0, 750 );
      controls = new THREE.PointerLockControls( camera );
      scene.add( controls.getObject() );
      var onKeyDown = function ( event ) {
        switch ( event.keyCode ) {
          case 38: // up
          case 87: // w
            moveForward = true;
            break;
          case 37: // left
          case 65: // a
            moveLeft = true; break;
          case 40: // down
          case 83: // s
            moveBackward = true;
            break;
          case 39: // right
          case 68: // d
            moveRight = true;
            break;
        }
      };
      var onKeyUp = function ( event ) {
        switch( event.keyCode ) {
          case 38: // up
          case 87: // w
            moveForward = false;
            break;
          case 37: // left
          case 65: // a
            moveLeft = false;
            break;
          case 40: // down
          case 83: // s
            moveBackward = false;
            break;
          case 39: // right
          case 68: // d
            moveRight = false;
            break;
        }
      };
      document.addEventListener( 'keydown', onKeyDown, false );
      document.addEventListener( 'keyup', onKeyUp, false );
      raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );
      // floor
      var floorGeometry = new THREE.PlaneGeometry( 2000, 2000, 100, 100 );
      floorGeometry.rotateX( - Math.PI / 2 );
			/*
			for ( var i = 0, l = floorGeometry.vertices.length; i < l; i ++ ) {
				var vertex = floorGeometry.vertices[ i ];
				vertex.x += Math.random() * 20 - 10;
				vertex.y += 1;
				vertex.z += Math.random() * 20 - 10;
			}
			for ( var i = 0, l = floorGeometry.faces.length; i < l; i ++ ) {
				var face = floorGeometry.faces[ i ];
				face.vertexColors[ 0 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0, Math.random() * 0.25 + 0.75 );
				face.vertexColors[ 1 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0, Math.random() * 0.25 + 0.75 );
				face.vertexColors[ 2 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0, Math.random() * 0.25 + 0.75 );
			}
      var floorMaterial = new THREE.MeshBasicMaterial( { vertexColors: THREE.VertexColors } );
			*/
			var floorMaterial = new THREE.MeshBasicMaterial();
      var floor = new THREE.Mesh( floorGeometry, floorMaterial );
      scene.add( floor );
      // objects

			var json_images = '{{ images|safe }}';
			var image_objs = JSON.parse(json_images);
			console.log(image_objs);
			var step = 1;
			var depstep = 1;
			$.each(image_objs, function(image_id,image_obj){

				var image_height = 30,
				image_width = image_height*image_obj.ratio;
				console.log(image_width);
				var planeGeometry = new THREE.BoxGeometry( image_width, image_height, 10 );
				var texture = new THREE.TextureLoader().load( image_obj.url );
				var planeMaterial =
				[
					new THREE.MeshBasicMaterial( { color: 0x000000, side: THREE.FrontSide } ), //right
					new THREE.MeshBasicMaterial( { color: 0x000000, side: THREE.FrontSide } ), //left
					new THREE.MeshBasicMaterial( { color: 0x000000, side: THREE.FrontSide } ), //top
					new THREE.MeshBasicMaterial( { color: 0x000000, side: THREE.FrontSide } ), //bottom
					new THREE.MeshBasicMaterial( { map:texture, side: THREE.FrontSide } ), //front
					new THREE.MeshBasicMaterial( { color: 0x000000, side: THREE.FrontSide } ) //back
				];
				var planeMaterial = new THREE.MeshFaceMaterial( planeMaterial );
				var plane = new THREE.Mesh( planeGeometry, planeMaterial );
				if ( step & 1 ) {
    			plane.position.x = -50;
					depstep++;
				} else {
    			plane.position.x = 50;
				}
        plane.position.y = 15;
				plane.position.z = -40 * depstep;
        scene.add( plane );
				objects.push( plane );
				step++;
			} );

      //
      renderer = new THREE.WebGLRenderer();
      renderer.setPixelRatio( window.devicePixelRatio );
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.getElementById('page_content').appendChild( renderer.domElement );
      //
      window.addEventListener( 'resize', onWindowResize, false );
    }
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize( window.innerWidth, window.innerHeight );
    }
    function animate() {
      requestAnimationFrame( animate );
      if ( controlsEnabled === true ) {
        raycaster.ray.origin.copy( controls.getObject().position );
        raycaster.ray.origin.y -= 10;
        var intersections = raycaster.intersectObjects( objects );
        var onObject = intersections.length > 0;
        var time = performance.now();
        var delta = ( time - prevTime ) / 1000;
        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;
        velocity.y -= 9.8 * 100.0 * delta;
        direction.z = Number( moveForward ) - Number( moveBackward );
        direction.x = Number( moveLeft ) - Number( moveRight );
        direction.normalize();
        if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;
        if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;
        if ( onObject === true ) {
          velocity.y = Math.max( 0, velocity.y );
          canJump = true;
        }
        controls.getObject().translateX( velocity.x * delta );
        controls.getObject().translateY( velocity.y * delta );
        controls.getObject().translateZ( velocity.z * delta );
        if ( controls.getObject().position.y < 10 ) {
          velocity.y = 0;
          controls.getObject().position.y = 10;
          canJump = true;
        }
        prevTime = time;
      }
      renderer.render( scene, camera );
    }

		</script>
{% endblock %}
