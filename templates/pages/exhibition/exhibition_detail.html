{% extends "base/base.html" %}
{% load staticfiles i18n %}

{% block title %}Выставки{% endblock %}

{% block pagetitle %}Выставки{% endblock %}

{% block content %}
		<script src="{% static 'js/three.js' %}"></script>
		<script src="{% static 'js/PointerLockControls.js' %}"></script>

    <div id="blocker">

			<div id="instructions">
				<span style="font-size:120px">Название выставки</span>
				<br />
				<br />
				(W, A, S, D = Движение, MOUSE = Смотреть по сторонам и наслаждаться)
			</div>

		<script>
    var camera, scene, renderer, controls;
    var objects = [];
    var raycaster;
    var blocker = document.getElementById( 'blocker' );
    var instructions = document.getElementById( 'instructions' );

    var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
    if ( havePointerLock ) {
      var element = document.body;
      var pointerlockchange = function ( event ) {
        if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
          controlsEnabled = true;
          controls.enabled = true;
          blocker.style.display = 'none';
        } else {
          controls.enabled = false;
          blocker.style.display = 'block';
          instructions.style.display = '';
        }
      };
      var pointerlockerror = function ( event ) {
        instructions.style.display = '';
      };

      document.addEventListener( 'pointerlockchange', pointerlockchange, false );
      document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
      document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );
      document.addEventListener( 'pointerlockerror', pointerlockerror, false );
      document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
      document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );
      instructions.addEventListener( 'click', function ( event ) {
        instructions.style.display = 'none';
        // Block screen
        element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
        element.requestPointerLock();
      }, false );
    } else {
      instructions.innerHTML = 'Ваш браузер не поддерживает блокировку указателя';
    }
    init();
    animate();
    var controlsEnabled = false;
    var moveForward = false;
    var moveBackward = false;
    var moveLeft = false;
    var moveRight = false;
    var canJump = false;
    var prevTime = performance.now();
    var velocity = new THREE.Vector3();
    var direction = new THREE.Vector3();
    function init() {
      camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );
      scene = new THREE.Scene();
      scene.background = new THREE.Color( 0xffffff );
      scene.fog = new THREE.Fog( 0xffffff, 0, 750 );
      var light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 0.75 );
      light.position.set( 0.5, 1, 0.75 );
      scene.add( light );
      controls = new THREE.PointerLockControls( camera );
      scene.add( controls.getObject() );
      var onKeyDown = function ( event ) {
        switch ( event.keyCode ) {
          case 38: // up
          case 87: // w
            moveForward = true;
            break;
          case 37: // left
          case 65: // a
            moveLeft = true; break;
          case 40: // down
          case 83: // s
            moveBackward = true;
            break;
          case 39: // right
          case 68: // d
            moveRight = true;
            break;
        }
      };
      var onKeyUp = function ( event ) {
        switch( event.keyCode ) {
          case 38: // up
          case 87: // w
            moveForward = false;
            break;
          case 37: // left
          case 65: // a
            moveLeft = false;
            break;
          case 40: // down
          case 83: // s
            moveBackward = false;
            break;
          case 39: // right
          case 68: // d
            moveRight = false;
            break;
        }
      };
      document.addEventListener( 'keydown', onKeyDown, false );
      document.addEventListener( 'keyup', onKeyUp, false );
      raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );
      // floor
      var floorGeometry = new THREE.PlaneGeometry( 2000, 2000, 100, 100 );
      floorGeometry.rotateX( - Math.PI / 2 );

      var floorMaterial = new THREE.MeshBasicMaterial() ;
      var floor = new THREE.Mesh( floorGeometry, floorMaterial );
      scene.add( floor );
      // objects
      var boxGeometry = new THREE.BoxGeometry( 40, 40, 40 );

      for ( var i = 0; i < 20; i ++ ) {
        var boxMaterial = new THREE.MeshPhongMaterial( { specular: 0xffffff, flatShading: true } );
        boxMaterial.color.setHSL( 0, 0, 1 );
        var box = new THREE.Mesh( boxGeometry, boxMaterial );
        box.position.x = Math.floor( Math.random() * 20 - 10 ) * 15;
        box.position.y = 20;
        box.position.z = Math.floor( Math.random() * 20 - 10 ) * 15;
        box.position.z = Math.floor( Math.random() * 20 - 10 ) * 15;
        scene.add( box );
        objects.push( box );
      }
      //
      renderer = new THREE.WebGLRenderer();
      renderer.setPixelRatio( window.devicePixelRatio );
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.getElementById('page_content').appendChild( renderer.domElement );
      //
      window.addEventListener( 'resize', onWindowResize, false );
    }
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize( window.innerWidth, window.innerHeight );
    }
    function animate() {
      requestAnimationFrame( animate );
      if ( controlsEnabled === true ) {
        raycaster.ray.origin.copy( controls.getObject().position );
        raycaster.ray.origin.y -= 10;
        var intersections = raycaster.intersectObjects( objects );
        var onObject = intersections.length > 0;
        var time = performance.now();
        var delta = ( time - prevTime ) / 1000;
        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;
        velocity.y -= 9.8 * 100.0 * delta;
        direction.z = Number( moveForward ) - Number( moveBackward );
        direction.x = Number( moveLeft ) - Number( moveRight );
        direction.normalize();
        if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;
        if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;
        if ( onObject === true ) {
          velocity.y = Math.max( 0, velocity.y );
          canJump = true;
        }
        controls.getObject().translateX( velocity.x * delta );
        controls.getObject().translateY( velocity.y * delta );
        controls.getObject().translateZ( velocity.z * delta );
        if ( controls.getObject().position.y < 10 ) {
          velocity.y = 0;
          controls.getObject().position.y = 10;
          canJump = true;
        }
        prevTime = time;
      }
      renderer.render( scene, camera );
    }

		</script>
{% endblock %}
