{% extends "base/base.html" %}
{% load staticfiles i18n %}

{% block title %}{{ exhibition.title }}{% endblock %}

{% block pagetitle %}{{ exhibition.title }}{% endblock %}

{% block content %}
<script src="{% static 'js/three.js' %}"></script>
<script src="{% static 'js/OrbitControls.js' %}"></script>

<script>

				var camera, scene, renderer;
				var cube_texture, loader;
				var mouse = new THREE.Vector2();

				init( );
				animation( );


				function init( ){
						camera = new THREE.PerspectiveCamera( 60, window.innerWidth/window.innerHeight, 0.01, 1000 );
						camera.position.set( 0, 0, 625 );
						camera.setFocalLength ( 40 );
						scene = new THREE.Scene();
						scene.background = new THREE.Color(0xffffff);


			//Cube 1
			var cube_geometry = new THREE.BoxGeometry( 100, 100, 100 );

			{% for exhibition in exhibitions %}

					var texture_right_{{exhibition.id}} = new THREE.TextureLoader().load( "{{exhibition.preview_right.url}}" ),
							texture_left_{{exhibition.id}} = new THREE.TextureLoader().load( "{{exhibition.preview_left.url}}" ),
							texture_top_{{exhibition.id}} = new THREE.TextureLoader().load( "{{exhibition.preview_top.url}}" ),
							texture_bottom_{{exhibition.id}} = new THREE.TextureLoader().load( "{{exhibition.preview_bottom.url}}" ),
							texture_front_{{exhibition.id}} = new THREE.TextureLoader().load( "{{exhibition.preview_front.url}}" ),
							texture_back_{{exhibition.id}} = new THREE.TextureLoader().load( "{{exhibition.preview_front.url}}" );

					var cubeMaterials_{{exhibition.id}} =
					[
						new THREE.MeshBasicMaterial( { map: texture_right_{{exhibition.id}}, side: THREE.BackSide } ), //right
						new THREE.MeshBasicMaterial( { map: texture_left_{{exhibition.id}}, side: THREE.BackSide } ), //left
						new THREE.MeshBasicMaterial( { map: texture_top_{{exhibition.id}}, side: THREE.BackSide } ), //top
						new THREE.MeshBasicMaterial( { map: texture_bottom_{{exhibition.id}}, side: THREE.BackSide } ), //bottom
						new THREE.MeshBasicMaterial( { map: texture_front_{{exhibition.id}}, side: THREE.BackSide } ), //front
						new THREE.MeshBasicMaterial( { map: texture_back_{{exhibition.id}}, side: THREE.BackSide } ) //back
					];
			var cube_material_{{exhibition.id}} = new THREE.MeshFaceMaterial( cubeMaterials_{{exhibition.id}} );
			var cube_{{exhibition.id}} = new THREE.Mesh( cube_geometry, cube_material_{{exhibition.id}} );
			cube_{{exhibition.id}}.position.x = 175 * {{exhibition.id}} - 175;
			scene.add( cube_{{exhibition.id}} )
			{% endfor %}
			/*Plane hor
			var shadowtex = new THREE.TextureLoader().load( "{% static 'img/shadowtex.jpg' %}" );
			var planeMaterials = new THREE.MeshBasicMaterial( { map: shadowtex, side: THREE.DoubleSide } );
			var geometry = new THREE.PlaneGeometry( 1300, 500 );
			var plane = new THREE.Mesh( geometry, planeMaterials );
			scene.add( plane );
			plane.position.set(350, -50.2, 0);
			plane.rotation.x = -Math.PI / 2; */

			//Line hor
			var geometry = new THREE.Geometry();
			geometry.vertices.push(
				new THREE.Vector3( -400, -40, -250 ),
				new THREE.Vector3( 1200,-40, -250 )
			);
			var line = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: 0x000000, linewidth: 2 } ) );
			scene.add(line);

			//Renderer
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			//document.body.appendChild( renderer.domElement );
			document.getElementById('page_content').appendChild( renderer.domElement );

			// Controls
			controls = new THREE.OrbitControls( camera, renderer.domElement );

			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			window.addEventListener( 'resize', onWindowResize, false );
	}

	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
	}

	function onDocumentMouseMove( event ) {
		event.preventDefault();
		mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
	}

	function animation( ){
		requestAnimationFrame( animation );
		controls.update()
		render();

	}

	function render() {
		renderer.render( scene, camera );
	}

</script>
{% endblock %}
